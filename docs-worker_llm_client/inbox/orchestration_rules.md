# Оркестрация (prototype): правила статусов и идемпотентность

Этот документ фиксирует минимальные правила, чтобы:

- было **видно состояние** выполнения (в `flow_runs/{runId}`),
- шаги были **идемпотентны**,
- ретраи не ломали данные,
- триггеры Firestore не запускали работу «по кругу».

## Статусы `flow_run.status`

- `PENDING`: документ создан, но ещё не начато (или не определён первый READY шаг).
- `RUNNING`: хотя бы один шаг в `RUNNING` или есть `READY` шаги.
- `SUCCEEDED`: все обязательные шаги успешно завершены.
- `FAILED`: есть `FAILED` шаг и политика флоу не допускает продолжение.
- `CANCELLED`: запуск отменён (ручной флаг).

## Статусы шага `steps[stepId].status`

- `PENDING`: шаг известен, но пока не готов к выполнению.
- `READY`: все зависимости (`dependsOn`) выполнены; шаг можно брать воркеру.
- `RUNNING`: воркер начал выполнение.
- `SUCCEEDED`: шаг завершился успешно.
- `FAILED`: шаг завершился с ошибкой (в `error`).
- `SKIPPED`: шаг сознательно пропущен политикой/ветвлением.
- `CANCELLED`: шаг отменён.

## Кто что делает

### `advance_flow` (Firestore trigger)

Реакция на update `flow_runs/{runId}`:

- вычисляет, какие шаги стали выполнимыми:
  - если `steps[s].status == PENDING` и все `dependsOn` имеют `SUCCEEDED`,
  - то переводит шаг в `READY`.
- поддерживает инвариант: воркеры **не ставят** `READY`.
- при обнаружении «терминальной ошибки»:
  - ставит `flow_run.status = FAILED`
  - и (опционально) блокирует дальнейшее продвижение.

### Воркеры шагов (`worker_ohlcv_export`, `worker_charts`, `worker_llm_report`, …)

Реагируют на update шага до `READY` и:

- **атомарно** (через транзакцию) переводят `READY -> RUNNING`, если статус всё ещё `READY`.
- выполняют работу.
- пишут артефакты в GCS.
- обновляют шаг:
  - `RUNNING -> SUCCEEDED` + `outputs.*`
  - или `RUNNING -> FAILED` + `error{code,message,details}`

## Идемпотентность (минимум для прототипа)

### Ключ идемпотентности

- `runId` + `stepId` должны однозначно определять **выходные артефакты**.
- Воркеры пишут в GCS по детерминированным путям, например:
  - `runs/<runId>/ohlcv/<timeframe>.json`
  - `charts/<runId>/<stepId>/manifest.json`

### Повторный запуск шага

Если шаг уже `SUCCEEDED`, воркер:

- **не перезаписывает** артефакты (или перезаписывает детерминированно тем же содержимым),
- не меняет `outputs` (кроме, возможно, `signed_url`/`expires_at`).

## Минимальная модель ошибок

### Поля `error`

- `code`: короткий код (например `GCS_WRITE_FAILED`, `BQ_QUERY_FAILED`, `LLM_TIMEOUT`)
- `message`: человекочитаемое сообщение
- `details`: произвольный JSON (для диагностики)

### Политика завершения run

В прототипе — простое правило:

- если любой шаг `FAILED` → `flow_run.status = FAILED`

Если понадобится «продолжать несмотря на ошибку», делаем это через:

- `steps[stepId].status = SKIPPED` (и опциональный `error`),
- или добавляем `policy` в `scope` (позже).

## Нестабильные внешние API: частичный результат (CHART_EXPORT)

Для `CHART_EXPORT` учитываем, что внешний API генерации изображений может вернуть меньше картинок, чем запрошено.

Контракт:

- В `steps[stepId].inputs` задаём:
  - `requests[]` (или упрощённо `chartTemplateId`)
  - `minImages` — минимальное число успешно полученных изображений
- Шаг **может** записать manifest даже при ошибке (для диагностики):
  - `outputs.outputsManifestGcsUri` указывает на `ChartsOutputsManifest`
  - внутри manifest:
    - `requested[]` — что просили
    - `items[]` — что реально получили
    - `failures[]` — что не удалось / ошибки

Правило статуса шага:

- если `len(items) >= minImages` → шаг может считаться `SUCCEEDED`
- иначе → шаг `FAILED` (и run, по умолчанию, тоже `FAILED`)


