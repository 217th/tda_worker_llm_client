#### 1\. Основной механизм: JSON Mode

##### 1.1. Концепция и принцип работы

**JSON Mode**  — это специальный режим работы Gemini API, который гарантирует, что ответ модели будет представлять собой синтаксически корректную JSON-строку. Ключевое преимущество этого режима заключается в том, что модель не просто пытается сгенерировать JSON, а принудительно следует заранее определённой структуре, описанной в виде схемы. Это устраняет необходимость в сложных и ненадёжных методах парсинга неструктурированного текста и обеспечивает высокую степень предсказуемости вывода.На уровне API-запроса этот режим активируется через конфигурацию генерации (generationConfig). Для этого используются два взаимосвязанных параметра:

* response\_mime\_type: Для активации режима этому параметру необходимо присвоить значение "application/json". Это указывает модели, что ожидаемый формат вывода — JSON.  
* response\_json\_schema: Этот параметр принимает объект JSON Schema, который детально описывает желаемую структуру, включая типы данных, обязательные поля и вложенные объекты. Модель использует эту схему как строгое руководство для генерации ответа.Далее мы рассмотрим, как сформировать такой запрос на практике.

##### 1.2. Входные данные: Формирование запроса

Чтобы получить структурированный вывод, запрос к модели должен состоять из следующих ключевых компонентов:

1. **Модель (Model):**  Необходимо выбрать модель, которая поддерживает структурированные ответы. Большинство современных моделей Gemini, включая gemini-2.5-flash, поддерживают эту функциональность. Рекомендуется сверяться с официальной документацией по моделям для получения актуальной информации о поддержке этой возможности.  
2. **Промт (Prompt/Contents):**  Это текстовая инструкция для модели, которая описывает задачу. Например: "Извлеки информацию о рецепте из этого текста и представь её в виде структурированных данных".  
3. **Конфигурация (Config):**  Это ключевой компонент, активирующий JSON Mode. Именно здесь задаются параметры response\_mime\_type (установленный в "application/json") и response\_json\_schema, который содержит схему для валидации ответа.

##### 1.3. Выходные данные: Обработка ответа

После успешного выполнения запроса API возвращает объект ответа. Сгенерированная JSON-строка находится в поле response.candidates0.content.parts0.text. Хотя SDK предоставляет удобный доступ через response.text, для максимальной точности и контроля рекомендуется обращаться к полной структуре ответа.Важно понимать, что на этом этапе вы получаете текстовое представление данных. Преобразование этой строки в нативный объект Python (например, словарь или объект Pydantic) является обязательным шагом для обеспечения целостности данных в вашем приложении. Этот парсинг не только делает данные удобными для работы в коде, но и служит критически важным уровнем валидации, гарантируя, что полученная структура полностью соответствует ожиданиям.

##### 1.4. Комплексный пример кода

Рассмотрим комплексный пример, в котором мы извлекаем информацию о рецепте из блока текста и преобразуем её в структурированный объект с помощью Pydantic.

1. **Импорты**  Сначала импортируем необходимые библиотеки: google.generativeai для работы с API и классы из pydantic и typing для определения схемы и валидации.  
2. **Определение схемы**  Мы определяем структуру данных с помощью классов Pydantic. Это делает код читаемым и позволяет автоматически генерировать JSON Schema.  
3. **Инициализация клиента и формирование запроса**  Инициализируем клиент и формируем промт с текстом, из которого нужно извлечь данные.  
4. **Вызов API и обработка результата**  Вызываем модель, передавая промт и конфигурацию с указанием MIME-типа и схемы, сгенерированной Pydantic.Как видно из примера, правильное определение схемы является ключом к успешному получению структурированных данных. Важно помнить, что Recipe.model\_validate\_json() проверяет  *структурную*  корректность, но не  *семантическую*  (например, не может определить, выдумала ли модель ингредиент). Этот аспект мы обсудим в разделе 4\.

#### 2\. Определение схемы с помощью Pydantic

##### 2.1. Преимущества Pydantic

Использование библиотеки Pydantic для определения схем в Python-приложениях, работающих с Gemini API, предоставляет несколько стратегических преимуществ:

* **Простота и наглядность:**  Вместо ручного составления громоздких JSON-объектов вы описываете структуру данных с помощью интуитивно понятных классов Python и стандартных тайп-хинтов (str, int, List). Это делает код более читаемым и простым в поддержке.  
* **Автоматическая генерация JSON Schema:**  Pydantic избавляет от необходимости вручную писать сложную и подверженную ошибкам JSON-схему. Метод .model\_json\_schema() автоматически преобразует ваш Python-класс в валидный JSON Schema, который можно напрямую передать в generationConfig.  
* **Встроенная валидация данных:**  После получения ответа от API метод .model\_validate\_json() не только преобразует JSON-строку в объект Python, но и автоматически проверяет соответствие всех полей заданным типам данных и ограничениям. Это критически важно для обеспечения надёжности приложения, так как защищает от некорректных или неожиданных данных от модели.

##### 2.2. Поддерживаемые типы и свойства

Gemini API поддерживает подмножество спецификации JSON Schema. Ниже приведена таблица с основными поддерживаемыми типами и свойствами.| Тип/Свойство | Описание || \------ | \------ || string | Текстовые данные. || number | Числа с плавающей запятой. || integer | Целые числа. || boolean | Логические значения true или false. || object | Структурированные данные с парами "ключ-значение". || array | Упорядоченные списки (массивы) элементов. || description | Подробное описание поля, которое помогает модели понять его назначение. || title | Короткое, читаемое название для поля. || enum | Ограничивает значение строкового поля предопределённым списком возможных вариантов. || properties | Определяет схему для каждого свойства (ключа) внутри объекта. || required | Список свойств, которые должны обязательно присутствовать в объекте. || items | Определяет схему для всех элементов внутри массива. |  
Хотя Pydantic и JSON Mode являются предпочтительным и наиболее надёжным инструментом для получения структурированных ответов, существуют и другие подходы, такие как Function Calling, которые могут быть полезны в определённых сценариях.

#### 3\. Альтернативный метод: Function Calling

##### 3.1. Анализ концепции

**Function Calling**  (вызов функций) представляет собой ещё один мощный способ получения структурированных данных от модели. Его основная идея заключается в том, что модель не просто форматирует конечный ответ, а генерирует запрос на вызов внешней, определённой разработчиком функции. Этот запрос содержит имя функции и её аргументы в виде структурированного JSON-объекта, который соответствует заранее заданной схеме.В отличие от JSON Mode, который нацелен на форматирование  *финального ответа пользователю* , Function Calling предназначен для сценариев, где модель должна взаимодействовать с внешними системами  *в процессе*  генерации ответа. Например, используйте JSON Mode, чтобы извлечь контактную информацию пользователя в итоговый JSON-объект. Используйте Function Calling, чтобы сначала получить ID пользователя из базы данных,  *прежде чем*  формулировать окончательный текстовый ответ. Аргументы, сгенерированные моделью для вызова функции, и являются искомыми структурированными данными.

##### 3.2. Практическая реализация в Python

Python SDK для Gemini (python-genai) предлагает два удобных способа реализации Function Calling:

1. **Автоматический вызов**  Это самый простой подход. Вы можете передать обычную функцию Python напрямую в параметр tools при вызове модели. SDK автоматически проанализирует её docstring и тайп-хинты, сгенерирует для неё декларацию (схему), отправит её модели, получит от модели запрос на вызов, исполнит вашу функцию с переданными аргументами и вернёт результат обратно модели для формирования финального ответа.  
2. **Ручное объявление и вызов**  Этот подход предоставляет больше контроля над процессом. Разработчик может либо вручную создать объект types.FunctionDeclaration, либо передать Python-функцию, отключив автоматическое выполнение с помощью automatic\_function\_calling. В ответ модель возвращает объект function\_calls, содержащий имя функции и аргументы. После этого разработчик должен самостоятельно исполнить соответствующую логику и отправить результат обратно модели с помощью Part.from\_function\_response. Этот метод предпочтителен, когда логика функции находится в отдельном микросервисе, требует асинхронного выполнения или когда необходимо реализовать сложную обработку ошибок и логику повторных попыток перед возвратом результата модели.

#### 4\. Обработка отклонений и обеспечение надежности

##### 4.1. Возможно ли отклонение от схемы?

Даже при использовании JSON Mode, который гарантирует синтаксическую корректность JSON, генерация может завершиться неудачно или выдать результат, который хоть и соответствует схеме, но является семантически некорректным. Важно понимать возможные причины сбоев. Поле finish\_reason, расположенное по пути response.candidates0.finish\_reason, предоставляет ценную информацию о том, почему генерация была остановлена.Основные причины сбоев:

* **MAX\_TOKENS** : Ответ был оборван, так как достиг максимального лимита токенов, указанного в запросе. Это может привести к неполной, синтаксически некорректной JSON-строке.  
* **SAFETY** : Ответ был заблокирован из\-за срабатывания фильтров безопасности. В этом случае сгенерированный контент не будет возвращён.  
* **RECITATION** : Ответ был заблокирован, так как содержал цитаты из защищённых материалов.  
* **Семантические ошибки** : Это наиболее тонкий вид ошибок. Модель может сгенерировать синтаксически идеальный JSON, который полностью соответствует схеме, но содержит логически неверные, вымышленные или нерелевантные данные (например, выдуманные имена или некорректные числовые значения, не основанные на исходном тексте).

##### 4.2. Стратегии обработки ошибок и валидации

Для создания надёжных приложений, использующих структурированный вывод, необходимо применять защитные механизмы в коде.**Что делать:**

1. **Анализируйте**  **finish\_reason**  **:**  Всегда проверяйте причину завершения генерации в объекте ответа (response.candidates0.finish\_reason). Это первый и самый быстрый способ понять, был ли ответ сгенерирован полностью и успешно, или же он был прерван по одной из причин, перечисленных выше.  
2. **Используйте клиентскую валидацию:**  Оборачивайте парсинг JSON-ответа в блок try...except. Это главный механизм защиты от синтаксически некорректного или структурно неверного JSON. При использовании Pydantic это выглядит особенно элегантно.  
3. **Применяйте лучшие практики промпт-инжиниринга:**  Качество структурированного вывода напрямую зависит от качества промта. Чёткие и подробные описания (description), как было показано в разделе 2, в полях схемы Pydantic, а также ясные инструкции в самом промте ("Извлеки информацию...", "Классифицируй текст...") значительно снижают вероятность семантических ошибок.  
4. **Реализуйте логику отката (Fallback):**  Предусмотрите в приложении альтернативный сценарий на случай, если валидация ответа не удалась. Это может быть повторный запрос к модели с изменённым или уточнённым промтом, возврат пользователю стандартизированного сообщения об ошибке или переход к ручной обработке данных.Сочетание встроенных возможностей Gemini API, таких как JSON Mode, и продуманных защитных механизмов на стороне вашего приложения является ключом к созданию стабильных и предсказуемых AI-решений.

