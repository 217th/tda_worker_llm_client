# Open questions for worker_llm_client

Keep this file current. Close questions explicitly (with decision + date/commit reference) or reword them precisely.

## Questions

| ID | Priority | Blocks planning? | Question | Current best guess | Owner | Target date |
|---:|:--------:|:---------------:|----------|--------------------|-------|-------------|
| 32 | High | Yes | SO: Чем валидируем ответ: Pydantic model vs JSON Schema validator? Какой уровень strictness (`extra=forbid`?) и какие детали ошибки сохраняем/логируем (санитизация)? | MVP: Pydantic `model_validate_json` + санитизированные ошибки (тип/путь поля), без raw payload. | TBD | TBD |
| 33 | High | Yes | SO: Что именно такое “repair prompt”: где хранится шаблон (код vs Firestore), что передаём модели (исходный JSON текст целиком? только сообщение об ошибке? schema?), и запрещаем ли модели добавлять текст вне JSON? | MVP: кодовый шаблон repair, включаем schema + ошибку валидации; просим вернуть **только JSON**. | TBD | TBD |
| 35 | Medium | No | SO: Как отражаем repair в persisted metadata: сохраняем ли attempt count, `finishReason`/usage по каждой попытке или только по финальной? | MVP: сохраняем только финальную попытку + `attempts.total` (число). | TBD | TBD |
| 38 | High | Yes | SO: Требуем ли от модели минимальные **семантические инварианты** в `output.details` (стабильные ключи) или оставляем `details` полностью свободным `additionalProperties=true`? | MVP: `details` остаётся свободным; стабильность — через `output.summary.markdown`. | TBD | TBD |
| 39 | Medium | No | SO: Нужно ли поддерживать `output.summary.html`: генерирует модель vs воркер конвертирует markdown→html (и как санитизируем HTML)? | MVP: только `output.summary.markdown`; html не требуем. | TBD | TBD |
| 40 | Medium | Yes | SO: Нужен ли `schemaVersion` у `LLMReportFile` (или у `output`) для эволюции формата и обратной совместимости? Если да — где и кто заполняет (модель/воркер)? | MVP: добавить `schemaVersion` (воркер заполняет) или фиксировать через `promptId`/`llmProfile` версию. | TBD | TBD |
| 44 | Medium | Yes | SO: Test vectors: какие обязательные негативные кейсы добавляем для structured output (truncated JSON, wrong type, missing required, extra text, multi-candidate) и как валидируем в CI? | MVP: добавить минимум 3 кейса (truncated/missing required/wrong type) и ожидаемые `error.code`. | TBD | TBD |

## Decisions (closed)

| ID | Date | Decision |
|---:|:----:|----------|
| 1 | 2025-12-26 | Gemini request parameters are provided only via `steps.*.inputs.llm.llmProfile` (authoritative; no overrides from prompt/model defaults). Allowlist: `model/modelName`, `temperature`, `topP`, `topK`, `maxOutputTokens`, `stopSequences`, `candidateCount`, `responseMimeType`, `responseSchema/jsonSchema`, `thinkingConfig(includeThoughts, thinkingLevel)`. |
| 2 | 2025-12-24 | Храним **расширенные метаданные** LLM выполнения в `flow_run` (tokens/finishReason/safety/requestId/latency/…), не только в логах. |
| 3 | 2025-12-24 | Канонический артефакт отчёта в GCS — **один JSON файл** по `contracts/llm_report_file.schema.json` (внутри есть `output.summary.markdown` и `output.details`). |
| 4 | 2025-12-26 | GCS naming — **детерминированный путь** `/<runId>/<timeframe>/<stepId>.json`, без `attempt` и без не-детерминированных timestamp в имени; `stepId` storage-safe (без `/ . :` и т.п.). |
| 9 | 2025-12-24 | В `flow_run` сохраняем только `gcs_uri` (без `signed_url`). |
| 10 | 2025-12-24 | Канонический формат GCS URI — `gs://...` (в контрактах используем `^gs://`). |
| 7 | 2025-12-26 | Prompt instructions live in Firestore collection `llm_prompts/{promptId}`; canonical schema is `contracts/llm_prompt.schema.json` (with notes in `contracts/llm_prompt.md` + example `contracts/examples/llm_prompt.example.json`). MVP required fields: `schemaVersion=1`, `systemInstruction` (string), `userPrompt` (string). Versioning is encoded in `promptId` by convention (`*_v1`, `*_v2`, ...). |
| 18 | 2025-12-26 | Context injection policy: worker downloads required artifacts from GCS itself (do not rely on model-side HTTP downloads). JSON artifacts (OHLCV, charts manifest, previous reports) are injected as text parts (fenced JSON blocks) with a hard per-artifact size limit of **64KB**; if exceeded, fail with `INVALID_STEP_INPUTS`. Chart images are passed as inline bytes (file/data parts) when supported, with a hard per-image limit of **256KB**; if exceeded, fail with `INVALID_STEP_INPUTS`. Additionally, worker appends a generated **UserInput** section listing each chart with a short description (prefer description copied into charts manifest from chart_template). |
| 21 | 2025-12-26 | `flow_run.scope` is injected into the prompt via the generated **UserInput** section (e.g., `Symbol: <scope.symbol>`). It does not need to be re-passed through step inputs unless an explicit override is required. |
| 8 | 2025-12-27 | `dependsOn` is satisfied only by `SUCCEEDED`. `SKIPPED` does **not** satisfy dependencies. |
| 11 | 2025-12-27 | Step timing is stored under `steps.<stepId>.outputs.execution.timing` (`startedAt/finishedAt/durationMs`). Do not add `steps.<stepId>.startedAt` to the `flow_run` schema. |
| 12 | 2025-12-27 | If `dependsOn` references a non-existent `stepId`, treat it as a configuration error and mark the step `FAILED` (non-retryable). |
| 14 | 2025-12-27 | Split-brain handling: if the deterministic GCS object already exists but Firestore was not finalized, the worker may reuse the object and finalize the step without re-calling the LLM. |
| 15 | 2025-12-27 | Standardize on Firestore optimistic preconditions (`update_time`) for claim/finalize (no Firestore transactions) across workers. |
| 16 | 2025-12-27 | MVP: no truncation/limits for `cloud_event_parsed.flowRunSteps` are required. Log all step summaries (still without inputs). |
| 17 | 2025-12-27 | MVP: `flow_run` + GCS is sufficient; no separate indexing storage (`reports/*`) on MVP. |
| 19 | 2025-12-27 | Worker updates only the step (`READY→RUNNING→SUCCEEDED/FAILED`). Orchestrator (`advance_flow`) reacts to step updates and decides `flow_run.status` terminal transitions. |
| 20 | 2025-12-27 | Safety blocks are treated as `FAILED` with error code `LLM_SAFETY_BLOCK` (non-retryable). Artifact write is optional; if written, it must not violate the canonical `llm_report_file` schema. |
| 22 | 2025-12-27 | MVP uses **AI Studio** endpoint (API key auth). Production may move to Vertex AI later (ADC/IAM). |
| 24 | 2025-12-27 | Zombie step recovery is out of scope for the worker. A separate reaper job or orchestrator policy handles stuck `RUNNING` steps. |
| 23 | 2025-12-27 | Timeout policy (MVP): target Cloud Function timeout `780s` (13m). Gemini request deadline `600s` (10m). Reserve `finalizeBudgetSeconds=120s` for GCS write + Firestore finalize; do not start new external calls (especially Gemini) when remaining time is below the finalize budget. |
| 5 | 2025-12-27 | Adopt a stable structured logging envelope + event taxonomy for `worker_llm_client` (based on previous workers): required fields include `service/env/component/event/severity/message/time` + correlation (`eventId/runId/stepId`) and `flowKey/timeframe/symbol` when known. Canonical event catalog and ordering is defined in `spec/observability.md` (CloudEvent ingestion → selection/claim → prompt/context → LLM → artifacts → finalize). |
| 6 | 2025-12-27 | CloudEvent `subject` observed pattern for Firestore document update trigger (gen2/Eventarc): `documents/<FLOW_RUNS_COLLECTION>/<runId>`. `runId` parsing rule: split the subject path by `/`, find the segment equal to `<FLOW_RUNS_COLLECTION>` (default `flow_runs`), take the next segment as `runId`, and validate `runId` against `contracts/flow_run.schema.json` (`runId` pattern). If parsing/validation fails, log `cloud_event_ignored` with `reason=invalid_subject` and exit (no Firestore writes). Also, `cloud_event_received` must always log `eventType` and `subject` (see `spec/observability.md`). |
| 13 | 2025-12-27 | Structured output invalidation policy (MVP): if structured output validation fails, do **at most 1** repair attempt (a second Gemini call) **only** if remaining invocation time is safely above `finalizeBudgetSeconds`; otherwise immediately finalize the step as `FAILED` with `INVALID_STRUCTURED_OUTPUT`. |
| 34 | 2025-12-27 | Repair attempts are not “full retries”: keep `maxGeminiAttempts=1` for the main call, and allow `maxRepairAttempts=1` only as a bounded recovery inside the same invocation when time budget allows. |
| 37 | 2025-12-27 | Structured output observability (MVP): log explicit events for invalidation and repair (`structured_output_invalid`, `structured_output_repair_attempt_started/finished`) including invalidation reason (parse/schema/finish_reason), `finishReason`, and safe diagnostics (length/hash + sanitized validation errors), without logging raw payload. |
| 29 | 2025-12-27 | Structured output `finishReason` mapping (MVP): `SAFETY` → step `FAILED` with `error.code=LLM_SAFETY_BLOCK` (non-retryable). Any outcome that results in invalid JSON / schema failure (including truncation like `MAX_TOKENS`) → step `FAILED` with `error.code=INVALID_STRUCTURED_OUTPUT` (subject to the single repair attempt policy). |
| 36 | 2025-12-27 | `INVALID_STRUCTURED_OUTPUT` artifacts (MVP): do **not** write raw model output to GCS. Optional: write a standard `llm_report_file` artifact that contains only a short failure summary and safe debug details (hash/len/reason/finishReason), never the raw payload. |
| 42 | 2025-12-27 | Orchestrator policy for `INVALID_STRUCTURED_OUTPUT` (MVP): treat it as terminal `FAILED` for automatic runs (no auto re-run with the same inputs). Manual rerun is allowed only by creating a new run/step (or an explicit operator action that creates a new attempt identity). |
| 28 | 2025-12-27 | `candidateCount` policy (MVP): require `candidateCount=1` for deterministic behavior and cost control. If `llmProfile.candidateCount` is not 1 (when provided), treat it as `LLM_PROFILE_INVALID` (non-retryable). |
| 30 | 2025-12-27 | Structured output size/truncation handling (MVP): the worker must not auto-adjust `llmProfile` (e.g., increase `maxOutputTokens`). If output is truncated or otherwise invalid (parse/schema), treat as `INVALID_STRUCTURED_OUTPUT` (subject to the single repair attempt policy). |
| 41 | 2025-12-27 | No fallback policy (MVP): if structured output is required by the step profile but is unsupported/unavailable for the chosen model/endpoint/SDK, do not fall back to markdown-only generation; treat as `LLM_PROFILE_INVALID` (non-retryable). |
| 43 | 2025-12-27 | Structured output data safety (MVP): treat raw model output JSON as sensitive; do not log it and do not persist it on failures. Persist/log only safe diagnostics (hash/len/reason/finishReason/URIs) and sanitized validation errors. No key-based redaction is required on MVP because raw payload is never emitted. |
| 25 | 2025-12-27 | Structured output schema boundary (MVP): Gemini structured output schema covers **only** `LLMReportFile.output` (model-owned). The worker always constructs the final `LLMReportFile` by combining worker-owned `metadata` + model-owned `output`. |
| 26 | 2025-12-27 | Structured output schema storage (MVP): schema source of truth is a dedicated Firestore collection `llm_schemas/{schemaId}` (immutable; versioned by `schemaId`) with `jsonSchema` stored inline in the doc. Steps reference it via `steps.<stepId>.inputs.llm.llmProfile.structuredOutput.schemaId` (authoritative for the worker). Logs/artifacts should include `schemaId` + `schemaSha256` for troubleshooting. |
| 27 | 2025-12-27 | Structured output schema validation (MVP): the worker must validate schema existence + supportability before calling Gemini. If schema is missing/invalid/unsupported, finalize as `FAILED` with `error.code=LLM_PROFILE_INVALID` (non-retryable). |
| 31 | 2025-12-27 | Structured output payload extraction (MVP): extract the JSON payload as a string by taking `candidates[0]` (MVP requires `candidateCount=1`), concatenating all `content.parts[*].text` in order. Do not apply regex extraction or strip code fences. Do not trim/normalize whitespace (hash/len are computed on the exact concatenated UTF-8 bytes). If no text parts are present, fall back to `response.text`. If still missing/empty, treat as invalid with `reason.kind=missing_text`. |
